1. 技术选型
前端框架: Flutter
状态管理: Riverpod
HTTP 客户端: http 或 dio
本地存储: shared_preferences 用于存储精简的历史记录（仅任务ID、Prompt、时间戳、状态等）
图片加载: cached_network_image 用于加载和缓存从服务器获取的图片
2. 应用架构
主页 (MyApp): 应用根组件。
底部导航栏 (BottomNavigationBar): "生成" 和 "历史" 两个选项卡。
生成页面 (GenerationScreen): 输入Prompt，提交任务。
历史页面 (HistoryScreen): 显示历史任务列表。
图片查看页面 (ImageViewScreen): 点击历史记录后跳转，用于查看图片。
3. 主要功能模块
3.1 生成页面 (GenerationScreen)
输入区域: Prompt、负向Prompt、参数设置。
提交按钮:
发送 POST 请求到本地 SD API (例如 http://127.0.0.1:7860/sdapi/v1/txt2img)。
存储任务信息: 成功提交后，将 任务ID (如果API提供)、Prompt、时间戳、初始状态 (如 "submitted") 存储到 shared_preferences 中。如果API不提供任务ID，可以使用一个自生成的唯一ID或时间戳作为标识。
更新UI: 可以将新提交的任务添加到状态管理器中，实时更新历史列表。
3.2 历史页面 (HistoryScreen)
加载历史: 从 shared_preferences 读取存储的任务信息列表。
列表显示:
缩略图: 这里可以显示一个占位符图片，或者如果 SD API 能够快速提供一个预览图的 URL，也可以尝试加载。但核心是点击后才加载完整图片。
Prompt 摘要: 显示生成时的 Prompt。
状态: 显示任务状态（"submitted", "processing", "completed", "failed"）。状态可能需要通过API查询更新。
时间戳: 记录生成的时间。
列表项点击: 点击列表项时，将该任务的 信息 (如ID、Prompt、时间戳、状态) 传递给 ImageViewScreen。
3.3 图片查看页面 (ImageViewScreen)
接收数据: 接收从 HistoryScreen 传递过来的任务信息。
判断状态:
检查任务状态。如果状态是 "completed"，则尝试获取图片。
如果状态是 "submitted" 或 "processing"，可以显示一个加载指示器，并尝试轮询 API 更新状态，直到状态变为 "completed" 或 "failed"。
获取图片: 当确认任务已完成时，使用 CachedNetworkImage 组件从 SD 服务器获取图片。
关键: 你需要知道 SD API 如何提供生成的图片。通常，SD API 在生成成功后会返回图片的本地路径或一个可以访问的 URL。你需要确保这个 URL 可以被 Flutter 应用访问（例如，SD WebUI 服务器开启了图片访问权限）。
例如，如果 API 返回了图片的 Base64 数据，你需要将其保存到本地临时文件，然后用 Image.file 或 Image.memory 显示。如果返回的是一个可访问的 URL（如 http://127.0.0.1:7860/file=...），则直接用 CachedNetworkImage.network(imageUrl)。
显示图片: 使用 InteractiveViewer 包装 CachedNetworkImage，实现缩放功能。
4. 关键实现点
4.1 与本地 SD API 通信
获取图片 URL: 这是最关键的一步。你需要确保 SD API 在生成图片后，能够提供一个可以通过 HTTP 访问的 URL。这通常取决于你使用的 SD 后端实现（如 AUTOMATIC1111 WebUI）。你需要查阅其 API 文档，了解 txt2img 或 img2img 等端点返回的数据结构，找到图片的访问路径或 URL。
图片访问权限: 确保 SD WebUI 服务器配置允许外部访问生成的图片文件。有时默认设置可能不允许直接通过 URL 访问。
4.2 本地存储
存储内容: 本地只存储 List<Map<String, dynamic>>，例如：
json
1234567891011121314
不包含图片数据。
4.3 图片加载与缓存
cached_network_image: 这个包会自动处理网络图片的加载、缓存和占位符显示。它非常适合你的场景，因为它会缓存从服务器获取的图片，避免重复请求。
这个方案确保了前端轻量化，并且图片始终从服务器获取，保证了数据的一致性。你需要重点配置好 SD 服务器的 API 和文件访问权限。